doctype html
html(lang='en', xmlns:fb='http://ogp.me/ns/fb#')
  head
    meta(http-equiv='content-type', content='text/html;charset=utf-8')
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1.0')
    meta(name='description', content='This animation uses d3.js geo and SVG transition.')
    link(rel='stylesheet', href='../css/bootstrap.min.css')
    link(rel='stylesheet', href='../css/v4.css')
    script(src='../js/jquery.min.js')
    script(src='../js/bootstrap.min.js')
    title Flight Animation
    link(rel='stylesheet', href='../css/v4gray.css')
    style.
      @media(max-width: 768px) {
        #map {
          margin-top: -100px;
        }
      }

      @media(min-width: 768px) {
        #map {
          margin-top: -300px;
        }
      }
  body
    .header
    .content
      .container
      #map
    .footer
    script(src='/socket.io/socket.io.js')
    script(src='../js/d3.v4.min.js')
    script(src='../js/queue.v1.min.js')
    script(src='../js/topojson.v1.min.js')
    script.
      var useDummy = true;

      var currentWidth = $('#map').width();
      var width = 938;
      var height = 620;

      var projection = d3.geoMercator()
                        .scale(150)
                        .translate([width / 2, height / 1.41]);

      var path = d3.geoPath()
                  .pointRadius(2)
                  .projection(projection);
        
      var svg = d3.select("#map")
                  .append("svg")
                  .attr("preserveAspectRatio", "xMidYMid")
                  .attr("viewBox", "0 0 " + width + " " + height)
                  .attr("width", currentWidth)
                  .attr("height", currentWidth * height / width);

      if(useDummy){
        var capitalCities = [];
      } else {
        var capitalCities = {};
      }

       function delta(plane, path) {
         var l = path.getTotalLength();
         var plane = plane;
         return function(i) {
           return function(t) {
             var p = path.getPointAtLength(t * l);

            var t2 = Math.min(t + 0.05, 1);
            var p2 = path.getPointAtLength(t2 * l);

            var x = p2.x - p.x;
            var y = p2.y - p.y;
            var r = 90 - Math.atan2(-y, x) * 180 / Math.PI;

            var s = Math.min(Math.sin(Math.PI * t) * 0.7, 0.3);

            return "translate(" + p.x + "," + p.y + ") scale(" + s + ") rotate(" + r + ")";
          }
        }
      }

      function trailDelta() {
        var l = this.getTotalLength(),
            i = d3.interpolateString("0," + l, l + "," + l);
        return function(t) { return i(t); };
      }

      function transition(plane, route, trail) {
        var l = route.node().getTotalLength();
        var duration = l*5;
        //- plane.transition()
        //-     .duration(l * 5)
        //-     .attrTween("transform", delta(plane, route.node()))
        //-     //- .each("end", destinationPulse(route, this))
        //-     .remove();
            
        trail.transition()
            .duration(duration)
            .attrTween("stroke-dasharray", trailDelta)
            .on("end", destinationPulse(route, duration))
            .remove();     
      }

      function destinationPulse(route, delayDuration){
        let dataCircle = route.datum();
        let pointDestination = projection(dataCircle.coordinates[1]);
          
        svg.append("circle")
          .datum(dataCircle)
          .attr("cx", pointDestination[0])
          .attr("cy", pointDestination[1])
          .attr("r", 0)
          .style("class", "destCircleMouse")
          .style("fill", "white")
          .style("fill-opacity", "1")
          .transition()
          .delay(delayDuration)
          .duration(100)
          .attr("r", "3px")
          .on("end", function (d) {
            d3.select(this)
              .transition()
              .duration(500)
              .attr("r", 10) // circle radius end
              .style("fill-opacity", "0")
              .on("end", function() { 
                this.remove(); 
              })
          });

          route.remove();
      }
        
      var defaultCity = "Indonesia";

      function fly(origin, destination) {
        if(origin == "UNDEFINED")
          origin = defaultCity;
        if(destination == "UNDEFINED")
          destination = defaultCity;

        var route = svg.append("path")
                      .datum({type: "LineString", coordinates: [capitalCities[origin], capitalCities[destination]]})
                      .attr("class", "route")
                      .attr("d", path);
          
        var trail = svg.append("path")
                      .datum({type: "LineString", coordinates: [capitalCities[origin], capitalCities[destination]]})
                      .attr("class", "trail")
                      .attr("d", path);               

        var plane = svg.append("path")
                      .attr("class", "plane")
                      .attr("d", "M-3.837,3.457l-24.399,48.587c-2.322,4.625-0.149,7.31,4.856,5.994L0.366,51.8l22.979,6.185    c5.001,1.346,7.202-1.333,4.923-5.982L4.497,3.499C2.217-1.15-1.515-1.168-3.837,3.457z")
                      .attr("width", "20px")
                      .attr("height", "20px");

        transition(plane, route, trail);
      }

      function loaded(error, countries, airports) {
        svg.append("g")
          .attr("class", "countries")
          .selectAll("path")
          .data(topojson.feature(countries, countries.objects.countries).features)
          .enter()
          .append("path")
          .attr("d", path);

        svg.append("g")
          .attr("class", "airports")
          .selectAll("path")
          .data(topojson.feature(airports, airports.objects.capitals).features)
          .enter()
          .append("path")
          .attr("id", function(d) {return d.id;})
          .attr("d", path);

        var geos = topojson.feature(airports, airports.objects.capitals).features;
        for (i in geos) {
          if(useDummy){
            capitalCities[i] = geos[i].geometry.coordinates;
          } else {
            capitalCities[geos[i].properties.country] = geos[i].geometry.coordinates;
          }
        }
        var lenCapitalCities = capitalCities.length;
        console.log(geos);
          
        if(useDummy){
          setInterval(function() {
            let rand1 = Math.floor(Math.random() * Math.floor(lenCapitalCities));
            let rand2 = Math.floor(Math.random() * Math.floor(lenCapitalCities));
            let rand1test = rand1 == 226 || rand1 == 227;
            let rand2test = rand2 == 226 || rand2 == 227;
            if(rand1 != rand2 && !rand1test && !rand2test)
              fly(rand1, rand2);
          }, 100);
        } else {
          var socket = io();
          socket.on('mongoStream', function (data) {
              console.log(data.fullDocument.src_country, data.fullDocument.dest_country);
              fly(data.fullDocument.src_country, data.fullDocument.dest_country);
          });
        }
      }
      
      $(function() {
        queue().defer(d3.json, "../json/countries2.topo.json")
              .defer(d3.json, "../json/capitals.topo.json")
              .await(loaded);

        $(window).resize(function() {
          currentWidth = $("#map").width();
          svg.attr("width", currentWidth);
          svg.attr("height", currentWidth * height / width);
        });
      });
